NAME
    Coro - coroutine process abstraction

SYNOPSIS
     use Coro;

     async {
        # some asynchronous thread of execution
     };

     # alternatively create an async coroutine like this:

     sub some_func : Coro {
        # some more async code
     }

     cede;

DESCRIPTION
    This module collection manages coroutines. Coroutines are similar to
    threads but don't run in parallel at the same time even on SMP machines.
    The specific flavor of coroutine used in this module also guarantees you
    that it will not switch between coroutines unless necessary, at
    easily-identified points in your program, so locking and parallel access
    are rarely an issue, making coroutine programming much safer than
    threads programming.

    (Perl, however, does not natively support real threads but instead does
    a very slow and memory-intensive emulation of processes using threads.
    This is a performance win on Windows machines, and a loss everywhere
    else).

    In this module, coroutines are defined as "callchain + lexical variables
    + @_ + $_ + $@ + $/ + C stack), that is, a coroutine has its own
    callchain, its own set of lexicals and its own set of perls most
    important global variables.

    $main
        This coroutine represents the main program.

    $current (or as function: current)
        The current coroutine (the last coroutine switched to). The initial
        value is $main (of course).

        This variable is strictly *read-only*. It is provided for
        performance reasons. If performance is not essential you are
        encouraged to use the "Coro::current" function instead.

    $idle
        A callback that is called whenever the scheduler finds no ready
        coroutines to run. The default implementation prints "FATAL:
        deadlock detected" and exits, because the program has no other way
        to continue.

        This hook is overwritten by modules such as "Coro::Timer" and
        "Coro::Event" to wait on an external event that hopefully wake up a
        coroutine so the scheduler can run it.

        Please note that if your callback recursively invokes perl (e.g. for
        event handlers), then it must be prepared to be called recursively.

  STATIC METHODS
    Static methods are actually functions that operate on the current
    coroutine only.

    async { ... } [@args...]
        Create a new asynchronous coroutine and return it's coroutine object
        (usually unused). When the sub returns the new coroutine is
        automatically terminated.

        See the "Coro::State::new" constructor for info about the coroutine
        environment.

        Calling "exit" in a coroutine will do the same as calling exit
        outside the coroutine. Likewise, when the coroutine dies, the
        program will exit, just as it would in the main program.

           # create a new coroutine that just prints its arguments
           async {
              print "@_\n";
           } 1,2,3,4;

    async_pool { ... } [@args...]
        Similar to "async", but uses a coroutine pool, so you should not
        call terminate or join (although you are allowed to), and you get a
        coroutine that might have executed other code already (which can be
        good or bad :).

        Also, the block is executed in an "eval" context and a warning will
        be issued in case of an exception instead of terminating the
        program, as "async" does. As the coroutine is being reused, stuff
        like "on_destroy" will not work in the expected way, unless you call
        terminate or cancel, which somehow defeats the purpose of pooling.

        The priority will be reset to 0 after each job, tracing will be
        disabled, the description will be reset and the default output
        filehandle gets restored, so you can change alkl these. Otherwise
        the coroutine will be re-used "as-is": most notably if you change
        other per-coroutine global stuff such as $/ you need to revert that
        change, which is most simply done by using local as in " local $/ ".

        The pool size is limited to 8 idle coroutines (this can be adjusted
        by changing $Coro::POOL_SIZE), and there can be as many non-idle
        coros as required.

        If you are concerned about pooled coroutines growing a lot because a
        single "async_pool" used a lot of stackspace you can e.g.
        "async_pool { terminate }" once per second or so to slowly replenish
        the pool. In addition to that, when the stacks used by a handler
        grows larger than 16kb (adjustable with $Coro::POOL_RSS) it will
        also exit.

    schedule
        Calls the scheduler. Please note that the current coroutine will not
        be put into the ready queue, so calling this function usually means
        you will never be called again unless something else (e.g. an event
        handler) calls ready.

        The canonical way to wait on external events is this:

           {
              # remember current coroutine
              my $current = $Coro::current;

              # register a hypothetical event handler
              on_event_invoke sub {
                 # wake up sleeping coroutine
                 $current->ready;
                 undef $current;
              };

              # call schedule until event occurred.
              # in case we are woken up for other reasons
              # (current still defined), loop.
              Coro::schedule while $current;
           }

    cede
        "Cede" to other coroutines. This function puts the current coroutine
        into the ready queue and calls "schedule", which has the effect of
        giving up the current "timeslice" to other coroutines of the same or
        higher priority.

        Returns true if at least one coroutine switch has happened.

    Coro::cede_notself
        Works like cede, but is not exported by default and will cede to any
        coroutine, regardless of priority, once.

        Returns true if at least one coroutine switch has happened.

    terminate [arg...]
        Terminates the current coroutine with the given status values (see
        cancel).

    killall
        Kills/terminates/cancels all coroutines except the currently running
        one. This is useful after a fork, either in the child or the parent,
        as usually only one of them should inherit the running coroutines.

    # dynamic methods

  COROUTINE METHODS
    These are the methods you can call on coroutine objects.

    new Coro \&sub [, @args...]
        Create a new coroutine and return it. When the sub returns the
        coroutine automatically terminates as if "terminate" with the
        returned values were called. To make the coroutine run you must
        first put it into the ready queue by calling the ready method.

        See "async" and "Coro::State::new" for additional info about the
        coroutine environment.

    $success = $coroutine->ready
        Put the given coroutine into the ready queue (according to it's
        priority) and return true. If the coroutine is already in the ready
        queue, do nothing and return false.

    $is_ready = $coroutine->is_ready
        Return wether the coroutine is currently the ready queue or not,

    $coroutine->cancel (arg...)
        Terminates the given coroutine and makes it return the given
        arguments as status (default: the empty list). Never returns if the
        coroutine is the current coroutine.

    $coroutine->join
        Wait until the coroutine terminates and return any values given to
        the "terminate" or "cancel" functions. "join" can be called
        concurrently from multiple coroutines.

    $coroutine->on_destroy (\&cb)
        Registers a callback that is called when this coroutine gets
        destroyed, but before it is joined. The callback gets passed the
        terminate arguments, if any.

    $oldprio = $coroutine->prio ($newprio)
        Sets (or gets, if the argument is missing) the priority of the
        coroutine. Higher priority coroutines get run before lower priority
        coroutines. Priorities are small signed integers (currently -4 ..
        +3), that you can refer to using PRIO_xxx constants (use the import
        tag :prio to get then):

           PRIO_MAX > PRIO_HIGH > PRIO_NORMAL > PRIO_LOW > PRIO_IDLE > PRIO_MIN
               3    >     1     >      0      >    -1    >    -3     >    -4

           # set priority to HIGH
           current->prio(PRIO_HIGH);

        The idle coroutine ($Coro::idle) always has a lower priority than
        any existing coroutine.

        Changing the priority of the current coroutine will take effect
        immediately, but changing the priority of coroutines in the ready
        queue (but not running) will only take effect after the next
        schedule (of that coroutine). This is a bug that will be fixed in
        some future version.

    $newprio = $coroutine->nice ($change)
        Similar to "prio", but subtract the given value from the priority
        (i.e. higher values mean lower priority, just as in unix).

    $olddesc = $coroutine->desc ($newdesc)
        Sets (or gets in case the argument is missing) the description for
        this coroutine. This is just a free-form string you can associate
        with a coroutine.

        This method simply sets the "$coroutine->{desc}" member to the given
        string. You can modify this member directly if you wish.

  GLOBAL FUNCTIONS
    Coro::nready
        Returns the number of coroutines that are currently in the ready
        state, i.e. that can be switched to. The value 0 means that the only
        runnable coroutine is the currently running one, so "cede" would
        have no effect, and "schedule" would cause a deadlock unless there
        is an idle handler that wakes up some coroutines.

    my $guard = Coro::guard { ... }
        This creates and returns a guard object. Nothing happens until the
        object gets destroyed, in which case the codeblock given as argument
        will be executed. This is useful to free locks or other resources in
        case of a runtime error or when the coroutine gets canceled, as in
        both cases the guard block will be executed. The guard object
        supports only one method, "->cancel", which will keep the codeblock
        from being executed.

        Example: set some flag and clear it again when the coroutine gets
        canceled or the function returns:

           sub do_something {
              my $guard = Coro::guard { $busy = 0 };
              $busy = 1;

              # do something that requires $busy to be true
           }

    unblock_sub { ... }
        This utility function takes a BLOCK or code reference and "unblocks"
        it, returning the new coderef. This means that the new coderef will
        return immediately without blocking, returning nothing, while the
        original code ref will be called (with parameters) from within its
        own coroutine.

        The reason this function exists is that many event libraries (such
        as the venerable Event module) are not coroutine-safe (a weaker form
        of thread-safety). This means you must not block within event
        callbacks, otherwise you might suffer from crashes or worse.

        This function allows your callbacks to block by executing them in
        another coroutine where it is safe to block. One example where
        blocking is handy is when you use the Coro::AIO functions to save
        results to disk.

        In short: simply use "unblock_sub { ... }" instead of "sub { ... }"
        when creating event callbacks that want to block.

BUGS/LIMITATIONS
     - you must make very sure that no coro is still active on global
       destruction. very bad things might happen otherwise (usually segfaults).

     - this module is not thread-safe. You should only ever use this module
       from the same thread (this requirement might be loosened in the future
       to allow per-thread schedulers, but Coro::State does not yet allow
       this).

SEE ALSO
    Support/Utility: Coro::Specific, Coro::State, Coro::Util.

    Locking/IPC: Coro::Signal, Coro::Channel, Coro::Semaphore,
    Coro::SemaphoreSet, Coro::RWLock.

    Event/IO: Coro::Timer, Coro::Event, Coro::Handle, Coro::Socket,
    Coro::Select.

    Embedding: <Coro:MakeMaker>

AUTHOR
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/

